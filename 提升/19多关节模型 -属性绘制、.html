<!DOCTYPE html>

<head>

</head>

<body>
    <div style="font-size: 20px; text-align: center;">多关节模型-属性</div>
    <canvas id="canvasDom" width="600" height="600"></canvas>
    <script src="../lib/webgl-utils.js"></script>
    <script src="../lib/cuon-matrix.js"></script>
    <!-- 矩阵变换库 -->
    <script src="../lib/webgl-debug.js"></script>
    <script src="../lib/cuon-utils.js"></script>
    <script>
        //定点着色器   说明了像素-定点的什么样的
        let vshader_source =
            'attribute vec4 a_Position;' +
            'attribute vec4 a_Color;' +
            'uniform mat4 u_mvpMatrix;' + //投影矩阵
            'uniform mat4 u_NormalMatrix;' + //变换矩阵
            'uniform mat4 u_ModelMatrix;' +
            'varying vec4 v_Color;' +
            'attribute vec4 a_normal;' + //法向量
            'varying vec3 v_normal;' +//  传递给片元着色器的光照方向
            'varying vec3 v_position;' + //传递给片元着色器的 位置
            'void main(){' +
            'gl_Position = u_mvpMatrix*a_Position;' + //模型视图诱因矩阵
            'v_normal = normalize(vec3(u_NormalMatrix*a_normal));' +  //法向量归一化   传给片元着色器
            'v_position = vec3(u_ModelMatrix*a_Position);' +
            'gl_PointSize=10.0;' +
            'v_Color=a_Color;' + //顶点颜色给  传递给片孙
            '}';
        //片元着色器   颜色是什么样
        let fshader_source =
            'precision mediump float;' +
            'varying vec4 v_Color;' +
            'varying vec3 v_normal;' +
            'varying vec3 v_position;' +
            'uniform vec3 u_AmbientLight;' +//环境光颜色
            'uniform vec3 u_LightColor;' + //光线颜色
            'uniform vec3 u_LightPosition;' + //点光源 位置
            'uniform vec3 u_LightColor1;' +//平行光颜色
            'uniform vec3 u_LightDrtct1;' +//平行光方向
            'void main(){' +
            'vec3 normal= normalize(v_normal);' +
            'vec3 lineDirect = normalize(u_LightPosition-v_position);' + //通过矢量减法  两个点 相减去 获取光线方向  点光源指向顶点
            'float nDotl = max(dot(lineDirect,normal),0.0);' +//计算法向量与光线点积  如果是大角度的话  会得到一个负值  给0
            'vec3 diffuse=u_LightColor*vec3(v_Color)*nDotl;' + //计算漫反射光颜色 
            'vec3 ambient=u_AmbientLight* vec3(v_Color);' +// 环境光漫反射颜色//

            'float nDotl1 = max(dot(u_LightDrtct1,normal),0.0);' +//计算平行光夹角
            'vec3 diffuse1=u_LightColor1*vec3(v_Color)*nDotl1;' + //计算平行光漫反射光颜色 



            'gl_FragColor=vec4(diffuse+ambient+diffuse1,1.0);' +  //平行光+点光源+环境光
            //  'gl_FragColor=v_Color;' +
            '}';
        //片元着色器个根据每个片元（像素的位置来设置颜色） gl_FragCoord的webgl内置函数（获取片在canvas中的坐标）颜色平滑


        window.onload = function () {
            let canvasDom = document.getElementById("canvasDom");
            let gl = getWebGLContext(canvasDom);//获得绘图上下文
            if (!gl) {
                console.log("不能使用webGl")
                return;
            }
            if (!initShaders(gl, vshader_source, fshader_source)) {
                console.log("不能初始化着色器");
                return;
            }
            let a_Position = gl.getAttribLocation(gl.program, 'a_Position') ///用变量 a_Positon 与顶点着色器  绑定
            let u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor') //绑定 片元着色
            let a_Color = gl.getAttribLocation(gl.program, "a_Color") //颜色数据
            if (!a_Position < 0) {
                console.log("没有能够获取着色器位置a_Positon")
                return;
            }
            const u_ViewMatirx = gl.getUniformLocation(gl.program, 'u_ViewMatirx')  //视图
            const u_ProjectMatrix = gl.getUniformLocation(gl.program, 'u_projectMatrix')  //投影
            const u_ModelMatrix = gl.getUniformLocation(gl.program, 'u_ModelMatrix')   //模型
            const u_mvpMatrix = gl.getUniformLocation(gl.program, 'u_mvpMatrix')
            const u_LightColor = gl.getUniformLocation(gl.program, 'u_LightColor') //光线颜色
            const u_LightDirection = gl.getUniformLocation(gl.program, 'u_LightDirection') //光线方向
            const a_normal = gl.getAttribLocation(gl.program, 'a_normal')
            const u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight')  //环境光颜色
            const u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix')
            const u_LightPosition = gl.getUniformLocation(gl.program, 'u_LightPosition') //光源位置

            const u_LightColor1 = gl.getUniformLocation(gl.program, 'u_LightColor1')
            const u_LightDrtct1 = gl.getUniformLocation(gl.program, 'u_LightDrtct1')




            var g_baseBuffer = null;     // Buffer object for a base
            var g_arm1Buffer = null;     // Buffer object for arm1
            var g_arm2Buffer = null;     // Buffer object for arm2
            var g_palmBuffer = null;     // Buffer object for a palm
            var g_fingerBuffer = null;   // Buffer object for fingers


            // mvpMatrix.lookAt(eyes.x, eyes.y, eyes.z, 0, 0, -10, 0, 1, 0)  //直接修改当前视角
            const initverterxBuffer = () => {
                // Vertex coordinate (prepare coordinates of cuboids for all segments)
                var vertices_base = new Float32Array([ // Base(10x2x10)
                    5.0, 2.0, 5.0, -5.0, 2.0, 5.0, -5.0, 0.0, 5.0, 5.0, 0.0, 5.0, // v0-v1-v2-v3 front
                    5.0, 2.0, 5.0, 5.0, 0.0, 5.0, 5.0, 0.0, -5.0, 5.0, 2.0, -5.0, // v0-v3-v4-v5 right
                    5.0, 2.0, 5.0, 5.0, 2.0, -5.0, -5.0, 2.0, -5.0, -5.0, 2.0, 5.0, // v0-v5-v6-v1 up
                    -5.0, 2.0, 5.0, -5.0, 2.0, -5.0, -5.0, 0.0, -5.0, -5.0, 0.0, 5.0, // v1-v6-v7-v2 left
                    -5.0, 0.0, -5.0, 5.0, 0.0, -5.0, 5.0, 0.0, 5.0, -5.0, 0.0, 5.0, // v7-v4-v3-v2 down
                    5.0, 0.0, -5.0, -5.0, 0.0, -5.0, -5.0, 2.0, -5.0, 5.0, 2.0, -5.0  // v4-v7-v6-v5 back
                ]);

                var vertices_arm1 = new Float32Array([  // Arm1(3x10x3)
                    1.5, 10.0, 1.5, -1.5, 10.0, 1.5, -1.5, 0.0, 1.5, 1.5, 0.0, 1.5, // v0-v1-v2-v3 front
                    1.5, 10.0, 1.5, 1.5, 0.0, 1.5, 1.5, 0.0, -1.5, 1.5, 10.0, -1.5, // v0-v3-v4-v5 right
                    1.5, 10.0, 1.5, 1.5, 10.0, -1.5, -1.5, 10.0, -1.5, -1.5, 10.0, 1.5, // v0-v5-v6-v1 up
                    -1.5, 10.0, 1.5, -1.5, 10.0, -1.5, -1.5, 0.0, -1.5, -1.5, 0.0, 1.5, // v1-v6-v7-v2 left
                    -1.5, 0.0, -1.5, 1.5, 0.0, -1.5, 1.5, 0.0, 1.5, -1.5, 0.0, 1.5, // v7-v4-v3-v2 down
                    1.5, 0.0, -1.5, -1.5, 0.0, -1.5, -1.5, 10.0, -1.5, 1.5, 10.0, -1.5  // v4-v7-v6-v5 back
                ]);

                var vertices_arm2 = new Float32Array([  // Arm2(4x10x4)
                    2.0, 10.0, 2.0, -2.0, 10.0, 2.0, -2.0, 0.0, 2.0, 2.0, 0.0, 2.0, // v0-v1-v2-v3 front
                    2.0, 10.0, 2.0, 2.0, 0.0, 2.0, 2.0, 0.0, -2.0, 2.0, 10.0, -2.0, // v0-v3-v4-v5 right
                    2.0, 10.0, 2.0, 2.0, 10.0, -2.0, -2.0, 10.0, -2.0, -2.0, 10.0, 2.0, // v0-v5-v6-v1 up
                    -2.0, 10.0, 2.0, -2.0, 10.0, -2.0, -2.0, 0.0, -2.0, -2.0, 0.0, 2.0, // v1-v6-v7-v2 left
                    -2.0, 0.0, -2.0, 2.0, 0.0, -2.0, 2.0, 0.0, 2.0, -2.0, 0.0, 2.0, // v7-v4-v3-v2 down
                    2.0, 0.0, -2.0, -2.0, 0.0, -2.0, -2.0, 10.0, -2.0, 2.0, 10.0, -2.0  // v4-v7-v6-v5 back
                ]);

                var vertices_palm = new Float32Array([  // Palm(2x2x6)
                    1.0, 2.0, 3.0, -1.0, 2.0, 3.0, -1.0, 0.0, 3.0, 1.0, 0.0, 3.0, // v0-v1-v2-v3 front
                    1.0, 2.0, 3.0, 1.0, 0.0, 3.0, 1.0, 0.0, -3.0, 1.0, 2.0, -3.0, // v0-v3-v4-v5 right
                    1.0, 2.0, 3.0, 1.0, 2.0, -3.0, -1.0, 2.0, -3.0, -1.0, 2.0, 3.0, // v0-v5-v6-v1 up
                    -1.0, 2.0, 3.0, -1.0, 2.0, -3.0, -1.0, 0.0, -3.0, -1.0, 0.0, 3.0, // v1-v6-v7-v2 left
                    -1.0, 0.0, -3.0, 1.0, 0.0, -3.0, 1.0, 0.0, 3.0, -1.0, 0.0, 3.0, // v7-v4-v3-v2 down
                    1.0, 0.0, -3.0, -1.0, 0.0, -3.0, -1.0, 2.0, -3.0, 1.0, 2.0, -3.0  // v4-v7-v6-v5 back
                ]);

                var vertices_finger = new Float32Array([  // Fingers(1x2x1)
                    0.5, 2.0, 0.5, -0.5, 2.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, 0.5, // v0-v1-v2-v3 front
                    0.5, 2.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 2.0, -0.5, // v0-v3-v4-v5 right
                    0.5, 2.0, 0.5, 0.5, 2.0, -0.5, -0.5, 2.0, -0.5, -0.5, 2.0, 0.5, // v0-v5-v6-v1 up
                    -0.5, 2.0, 0.5, -0.5, 2.0, -0.5, -0.5, 0.0, -0.5, -0.5, 0.0, 0.5, // v1-v6-v7-v2 left
                    -0.5, 0.0, -0.5, 0.5, 0.0, -0.5, 0.5, 0.0, 0.5, -0.5, 0.0, 0.5, // v7-v4-v3-v2 down
                    0.5, 0.0, -0.5, -0.5, 0.0, -0.5, -0.5, 2.0, -0.5, 0.5, 2.0, -0.5  // v4-v7-v6-v5 back
                ]);

                // Normal
                var normals = new Float32Array([
                    0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front
                    1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right
                    0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up
                    -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left
                    0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // v7-v4-v3-v2 down
                    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0  // v4-v7-v6-v5 back
                ]);

                // Indices of the vertices
                var indices = new Uint8Array([
                    0, 1, 2, 0, 2, 3,    // front
                    4, 5, 6, 4, 6, 7,    // right
                    8, 9, 10, 8, 10, 11,    // up
                    12, 13, 14, 12, 14, 15,    // left
                    16, 17, 18, 16, 18, 19,    // down
                    20, 21, 22, 20, 22, 23     // back
                ]);


                //法线缓冲区数据
                const normalBuffer = new gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW)  //法线的缓冲
                gl.vertexAttribPointer(a_normal, 3, gl.FLOAT, false, 0, 0)//  间隔是0 偏移也是0
                gl.enableVertexAttribArray(a_normal) //开启分配开关         
                //索引数据
                var indexBuffer = gl.createBuffer();
   
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);



                gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0)  //光线为颜色 
                gl.uniform3f(u_LightPosition, 2.0, -2.0, 2.0)   //点光源位置
                gl.uniform3f(u_AmbientLight, 0.4, 0.4, 0.4, 1.0);  //环境光颜色
                gl.vertexAttrib4f(a_Color, 1.0, 0.4, 0.0, 1.0);  //物体颜色
                gl.uniform3f(u_LightDrtct1, 0.0, 0.5, 0.7) //平行光方向
                gl.uniform3f(u_LightColor1, 0.9, 0.9, 0.9)

                debugger  
                //把数据写到缓冲区里面，并获取一个并且将buff二部 加上两个属性  用来标识是哪个物体
                g_baseBuffer = initArrayBufferForLaterUse(gl, vertices_base, 3, gl.FLOAT);
                g_arm1Buffer = initArrayBufferForLaterUse(gl, vertices_arm1, 3, gl.FLOAT);
                g_arm2Buffer = initArrayBufferForLaterUse(gl, vertices_arm2, 3, gl.FLOAT);
                g_palmBuffer = initArrayBufferForLaterUse(gl, vertices_palm, 3, gl.FLOAT);
                g_fingerBuffer = initArrayBufferForLaterUse(gl, vertices_finger, 3, gl.FLOAT);

                return indices.length
            }

            const initArrayBufferForLaterUse = (gl, data, num, type) => {
                var buffer = gl.createBuffer();   // Create a buffer object
                if (!buffer) {
                    console.log('Failed to create the buffer object');
                    return null;
                }
                // Write date into the buffer object
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

                // Store the necessary information to assign the object to the attribute variable later
                buffer.num = num;
                buffer.type = type;

                return buffer;
            }


            const n = initverterxBuffer();
            gl.clearColor(0.0, 0.0, 0.0, 1);//设置背景色
            gl.enable(gl.DEPTH_TEST)  //深度检测  让其不会遮盖
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

            ///绘制五个部件  基做 -前臂-后壁 -手掌-手指1 手指2   六个部件
            var g_modelMatrix = new Matrix4();
            let mvpMatrix = new Matrix4()
            let g_arm1Angle = 90.0; //arm1当前角度

            let g_joint1Angle = 45.0;  //第二个模型的旋转角度
            let g_joint2Angle = 0.0;  //第二个模型的旋转角度
            let g_joint3Angle = 0.0

            var ANGLE_STEP = 3.0;    // The increments of rotation angle (degrees)
            let g_normalMatix = new Matrix4()
            const eyes = {
                x: 20.0, y: 10.0, z: 30.0
            }
            const viewMartix = new Matrix4()// 视图矩阵
            viewMartix.setPerspective(50.0, 1.0, 1.0, 100.0)  //投影矩阵
            viewMartix.lookAt(eyes.x, eyes.y, eyes.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)  //设置设界矩阵变换   //


            const draw = (n, viewMartix, mvpMatrix, u_NormalMatrix) => {

                gl.enable(gl.DEPTH_TEST)  //深度检测  让其不会遮盖
                gl.clearColor(0.0, 0.0, 0.0, 1);//设置背景色
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

                const baseHeight = 2.0;
                g_modelMatrix.setTranslate(0.0, -12.0, 0.0);
                drawElement(n, g_baseBuffer, viewMartix, mvpMatrix, u_NormalMatrix)  //绘制底座  10*10*10的大小

                const arm1length = 10.0;//绘制后壁 
                g_modelMatrix.translate(0.0, baseHeight, 0.0);  //在 底座上方  上移底座的高度
                g_modelMatrix.rotate(g_arm1Angle, 0.0, 1.0, 0.0);
                // g_modelMatrix.scale(1.3, 1.0, 1.3)
                drawElement(n, g_arm1Buffer, viewMartix, mvpMatrix, u_NormalMatrix)   //后壁  3.0*10** 大小 

                const arm2length = 10.0; //绘制前臂
                g_modelMatrix.translate(0.0, arm1length, 0.0);
                g_modelMatrix.rotate(g_joint1Angle, 0.0, 0.0, 1.0,);
                // g_modelMatrix.scale(1.3, 1.0, 1.3)
                drawElement(n, g_arm2Buffer, viewMartix, mvpMatrix, u_NormalMatrix)  //前臂   2。0*10*2.0

                const palmlength = 2.0;   //绘制手掌
                g_modelMatrix.translate(0.0, arm2length, 0.0);
                g_modelMatrix.rotate(g_joint2Angle, 0.0, 1.0, 0.0,);
                drawElement(n, g_palmBuffer, viewMartix, mvpMatrix, u_NormalMatrix)


                g_modelMatrix.translate(0.0, 1.0, 2.0);  //绘制手指1
                g_modelMatrix.rotate(g_joint3Angle, 1.0, 0.0, 0.0);
                drawElement(n, g_fingerBuffer, viewMartix, mvpMatrix, u_NormalMatrix)

                g_modelMatrix.translate(0.0, 1.0, -2.0);   //绘制手指2
                g_modelMatrix.rotate(-g_joint3Angle, 1.0, 0.0, 0.0);
                drawElement(n, g_fingerBuffer, viewMartix, mvpMatrix, u_NormalMatrix)
            }

            //绘制盒子
            const drawElement = (n, buffer, viewProjectMatrix, mvpMatrix, u_NormalMatrix) => {

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
                gl.vertexAttribPointer(a_Position, buffer.num, buffer.type, false, 0, 0)  //写入数据
                gl.enableVertexAttribArray(a_Position)
                mvpMatrix.set(viewProjectMatrix);
                mvpMatrix.multiply(g_modelMatrix);

                gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix.elements)
                g_normalMatix.setInverseOf(g_modelMatrix)  //逆矩阵
                g_normalMatix.transpose()  //矩阵转置
                gl.uniformMatrix4fv(u_ModelMatrix, false, g_modelMatrix.elements) 
                gl.uniformMatrix4fv(u_NormalMatrix, false, g_normalMatix.elements)  //运动矩阵  法向量
                gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0)
            }
          //其实就是将数据分开
            draw(n, viewMartix, mvpMatrix, u_NormalMatrix)

            window.addEventListener("keydown", event => {   ///这里如果物体位置发生变化了  法线理论也是变化的才行，所以这里不起作用
                let keyCode = event.keyCode

                switch (event.keyCode) {

                    //向上
                    case 38: // Up arrow key -> the positive rotation of joint1 around the z-axis
                        if (g_joint1Angle < 135.0) g_joint1Angle += ANGLE_STEP;
                        break;
                    //向下
                    case 40: // Down arrow key -> the negative rotation of joint1 around the z-axis
                        if (g_joint1Angle > -135.0) g_joint1Angle -= ANGLE_STEP;
                        break;
                    case 39: // Right arrow key -> the positive rotation of arm1 around the y-axis
                        g_arm1Angle = (g_arm1Angle + ANGLE_STEP) % 360;
                        break;
                    case 37: // Left arrow key -> the negative rotation of arm1 around the y-axis
                        g_arm1Angle = (g_arm1Angle - ANGLE_STEP) % 360;
                        break;
                    case 69:  //E键
                        g_joint2Angle = (g_joint2Angle + ANGLE_STEP) % 360 // 手掌
                        break;
                    case 70:  //x键
                        g_joint2Angle = (g_joint2Angle - ANGLE_STEP) % 360 // 手掌
                        break;
                    case 86://V
                        if (g_joint3Angle < 60) {
                            g_joint3Angle = (g_joint3Angle + ANGLE_STEP) % 360 // 手掌
                        }
                        break
                    case 67://V
                        if (g_joint3Angle > -60) {
                            g_joint3Angle = (g_joint3Angle - ANGLE_STEP) % 360 // 手掌
                        }
                    default:
                        break;
                }
                // Draw the robot arm
                draw(n, viewMartix, mvpMatrix, u_NormalMatrix);
            })
        }

    </script>
</body>

</html>