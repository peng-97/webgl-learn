<!DOCTYPE html>

<head>

</head>

<body>
    <div style="font-size: 20px; text-align: center;">选中物体</div>
    <div style="font-size: 20px; text-align: center;"></div>
    <canvas id="canvasDom" width="600" height="600"></canvas>
    <script src="../lib/webgl-utils.js"></script>
    <script src="../lib/cuon-matrix.js"></script>
    <!-- 矩阵变换库 -->
    <script src="../lib/webgl-debug.js"></script>
    <script src="../lib/cuon-utils.js"></script>
    <script>
        //定点着色器   说明了像素-定点的什么样的
        let vshader_source =
            'attribute vec4 a_Position;' +
            'attribute vec4 a_Color;' +
            'uniform mat4 u_mvpMatrix;' +
            'varying vec4 v_Color;' +
            'attribute float u_face;' +
            'uniform int u_PickedFace;\n' + // Surface number of selected face
            'void main(){' +
            'gl_Position = u_mvpMatrix*a_Position;' +
            'int face=int(u_face);' +
            'gl_PointSize=10.0;' +
            'vec3 color;' +
            'if(face==u_PickedFace){' +
            'color=vec3(1.0,1.0,1.0); }' +
            'else' +
            '{color=vec3(a_Color);}' +
            'if(u_PickedFace==0){' +
            ' v_Color=vec4(color,u_face/255.0) ;}else{' +
            'v_Color=vec4(color,a_Color.a);}' + 
            '}';


        //positong  表示是呢嘛位置
        //片元着色器   颜色是什么样
        let fshader_source =
            '#ifdef GL_ES\n' +
            'precision mediump float;\n' +
            '#endif\n' +
            'varying vec4 v_Color;' +
            'void main(){' +
            'gl_FragColor=v_Color;' +  //懒得传了直接给数据
            '}';
        //片元着色器个根据每个片元（像素的位置来设置颜色） gl_FragCoord的webgl内置函数（获取片在canvas中的坐标）颜色平滑


        window.onload = function () {
            let canvasDom = document.getElementById("canvasDom");
            let gl = getWebGLContext(canvasDom);//获得绘图上下文
            if (!gl) {
                console.log("不能使用webGl")
                return;
            }
            if (!initShaders(gl, vshader_source, fshader_source)) {
                console.log("不能初始化着色器");
                return;
            }
            let a_Position = gl.getAttribLocation(gl.program, 'a_Position') ///用变量 a_Positon 与顶点着色器  绑定
            let u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor') //绑定 片元着色
            let a_Color = gl.getAttribLocation(gl.program, "a_Color") //颜色数据
            if (!a_Position < 0) {
                console.log("没有能够获取着色器位置a_Positon")
                return;
            }
            const u_ViewMatirx = gl.getUniformLocation(gl.program, 'u_ViewMatirx')
            const u_ProjectMatrix = gl.getUniformLocation(gl.program, 'u_projectMatrix')
            const u_mvpMatrix = gl.getUniformLocation(gl.program, 'u_mvpMatrix')
            const u_face = gl.getAttribLocation(gl.program, 'u_face');
            const u_PickedFace = gl.getUniformLocation(gl.program, 'u_PickedFace')
            //原本最初的视图
            const eyes = {
                x: 3, y: 3, z: 7
            }
            const viewMartix = new Matrix4()// 视图矩阵
            viewMartix.setLookAt(eyes.x, eyes.y, eyes.z, 0, 0, 0, 0, 1, 0)  //设置设界矩阵变换   //

            const projectMaatrix = new Matrix4()
            projectMaatrix.setPerspective(30, 1, 1, 100) //垂直视角，宽高比。近位置  远位置

            const modelMatrix = new Matrix4()
            modelMatrix.setRotate(1, 1, 1, 1)

            const mvpMatrix = new Matrix4()
            mvpMatrix.set(projectMaatrix).multiply(viewMartix).multiply(modelMatrix)

            // mvpMatrix.lookAt(eyes.x, eyes.y, eyes.z, 0, 0, -10, 0, 1, 0)  //直接修改当前视角
            const initverterxBuffer = () => {
                //九个点  绘制三个三角形
                const verticesSizes = new Float32Array([   // Vertex coordinates
                    1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0,  // v0-v1-v2-v3 front
                    1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0,  // v0-v3-v4-v5 right
                    1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,  // v0-v5-v6-v1 up
                    -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0,  // v1-v6-v7-v2 left
                    -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,  // v7-v4-v3-v2 down
                    1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0   // v4-v7-v6-v5 back
                ]);
                var colors = new Float32Array([     // Colors
                    0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0,  // v0-v1-v2-v3 front(blue)
                    0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4,  // v0-v3-v4-v5 right(green)
                    1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4,  // v0-v5-v6-v1 up(red)
                    1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4,  // v1-v6-v7-v2 left
                    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,  // v7-v4-v3-v2 down
                    0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0   // v4-v7-v6-v5 back
                ]);


                var faces = new Uint8Array([   // Faces
                    1, 1, 1, 1,     // v0-v1-v2-v3 front
                    2, 2, 2, 2,     // v0-v3-v4-v5 right
                    3, 3, 3, 3,     // v0-v5-v6-v1 up
                    4, 4, 4, 4,     // v1-v6-v7-v2 left
                    5, 5, 5, 5,     // v7-v4-v3-v2 down
                    6, 6, 6, 6,     // v4-v7-v6-v5 back
                ]);
                // Indices of the vertices
                var indices = new Uint8Array([       // Indices of the vertices
                    0, 1, 2, 0, 2, 3,    // front
                    4, 5, 6, 4, 6, 7,    // right
                    8, 9, 10, 8, 10, 11,    // up
                    12, 13, 14, 12, 14, 15,    // left
                    16, 17, 18, 16, 18, 19,    // down
                    20, 21, 22, 20, 22, 23     // back
                ]);
                var n = 9;
                //视点  观察点   上方向

                const vertesizeBuffer = new gl.createBuffer();

                //绑定缓冲区并写入 固定写法 
                gl.bindBuffer(gl.ARRAY_BUFFER, vertesizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, verticesSizes, gl.STATIC_DRAW)



                //element  缓冲写法   固定写法 与 buffer不一致的地方   索引数局的缓冲区对象
                const indexBuffer = new gl.createBuffer() //索引缓冲
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)

                gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix.elements)
                //顶点缓冲区
                const fSize = verticesSizes.BYTES_PER_ELEMENT; //字节数
                gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);//间隔是0 偏移也是0
                gl.enableVertexAttribArray(a_Position);//开启分配开关
                const colorBuffer = new gl.createBuffer()
                //增加一个颜色缓冲区数据
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW)
                gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 0, 0)//  间隔是0 偏移也是0
                gl.enableVertexAttribArray(a_Color) //开启分配开关

                const facebuffer = new gl.createBuffer()
                gl.bindBuffer(gl.ARRAY_BUFFER, facebuffer)
                gl.bufferData(gl.ARRAY_BUFFER, faces, gl.STATIC_DRAW)
                gl.vertexAttribPointer(u_face, 1, gl.UNSIGNED_BYTE, false, 0, 0)
                gl.enableVertexAttribArray(u_face)
                gl.uniform1i(u_PickedFace, -1);  // Pass true to u_Clicked\   默认是0
                return indices.length
            }
            const n = initverterxBuffer();




            let lasttime = Date.now()
            const draw = () => {
                let now = Date.now() //当前时间
                let p = now - lasttime;
                viewMartix.rotate(p / 150.0, 1.0, 0.0, 0.0, 0.0,)  //设置设界矩阵变换   
                viewMartix.rotate(p / 50.0, 0.0, 1.0, 0.0, 0.0,)  //设置设界矩阵变换
                lasttime = now
                mvpMatrix.set(projectMaatrix).multiply(viewMartix).multiply(modelMatrix)
                gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix.elements)
                gl.clearColor(0.0, 0.0, 0.0, 1);//设置背景色
                gl.enable(gl.DEPTH_TEST)  //深度检测  让其不会遮盖
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
                gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0)
                requestAnimationFrame(draw)
            }
            draw()


            canvasDom.addEventListener("click", event => {
                const x = event.clientX
                const y = event.clientY;
                var rect = event.target.getBoundingClientRect();
                console.log(x, y, rect.left, rect.top)
                if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
                    var x_in_canvas = x - rect.left, y_in_canvas = rect.bottom - y;
                    var picked = false;

                    // draw(gl, n, currentAngle, viewProjMatrix, u_MvpMatrix); // Draw cube with red
                    // Read pixel at the clicked position
                    var pixels = new Uint8Array(4); // Array for storing the pixel value
                    gl.uniform1i(u_PickedFace, 0);  // P
                    draw()   //这里需要绘制才行

                    gl.readPixels(x_in_canvas, y_in_canvas, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);  //计像素点的颜色
                    console.log(pixels)
                    gl.uniform1i(u_PickedFace, pixels[3]);  // Pass true to u_Clicked\
                    draw()
                    // gl.uniform1i(    `, 0);  // Pass false to u_Clicked(rewrite the cube)
                    // draw(gl, n, currentAngle, viewProjMatrix, u_MvpMatrix); // Draw the cube
                    if (picked) alert('The cube was selected! ');
                }
            })

        }

    </script>
</body>

</html>