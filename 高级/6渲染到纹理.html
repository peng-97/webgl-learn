<!DOCTYPE html>

<head>

</head>

<body>
    <div style="font-size: 20px; text-align: center;">渲染到纹理</div>
    <canvas id="canvasDom" width="500" height="500"></canvas>
    <script src="../lib/webgl-utils.js"></script>
    <script src="../lib/cuon-matrix.js"></script>
    <!-- 矩阵变换库 -->
    <script src="../lib/webgl-debug.js"></script>
    <script src="../lib/cuon-utils.js"></script>
    <script>
        //定点着色器   说明了像素-定点的什么样的
        const vshader_source =
            'attribute vec4 a_Position;\n' +
            'attribute vec2 a_TexCoord;\n' +
            'uniform mat4 u_MvpMatrix;\n' +
            'varying vec2 v_TexCoord;\n' +
            'void main() {\n' +
            '  gl_Position = u_MvpMatrix * a_Position;\n' +
            '  v_TexCoord = a_TexCoord;\n' +
            '}\n';

        // Fragment shader program
        const fshader_source =
            '#ifdef GL_ES\n' +
            'precision mediump float;\n' +
            '#endif\n' +
            'uniform sampler2D u_Sampler;\n' +
            'varying vec2 v_TexCoord;\n' +
            'void main() {\n' +
            '  gl_FragColor = texture2D(u_Sampler, v_TexCoord);\n' +
            '}\n';
        window.onload = function () {
            let canvasDom = document.getElementById("canvasDom");
            let gl = getWebGLContext(canvasDom);//获得绘图上下文
            if (!gl) {
                console.log("不能使用webGl")
                return;
            }
            if (!initShaders(gl, vshader_source, fshader_source)) {
                console.log("不能初始化着色器");
                return;
            }
            let a_Position = gl.getAttribLocation(gl.program, 'a_Position') ///用变量 a_Positon 与顶点着色器  绑定
            let a_TextCoord = gl.getAttribLocation(gl.program, 'a_TexCoord')
            let u_mvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix')
            debugger
            if (!a_Position < 0) {
                console.log("没有能够获取着色器位置a_Positon")
                return;
            }

            const modelMatrix = new Matrix4()   //模型矩阵
            const mvpMatrix = new Matrix4()  //模型视图投影矩阵


            const offsetScreen_Width = 256
            const offsetScreent_hight = 256
            /**
            * 初始化纹理
            * */
            const inittextTure = () => {
                let texture = gl.createTexture();//创建纹理对象
                let u_Sample = gl.getUniformLocation(gl.program, 'u_Sampler')  //获取位置
                let image = new Image()
                image.onload = () => {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);//将纹理对象Y轴反转 因为图片坐标是向右向下的，但是webgl是向右向上的，所以为需要Y轴反转
                    gl.bindTexture(gl.TEXTURE_2D, texture)
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
                    gl.uniform1i(u_Sample, 0)
                    gl.bindTexture(gl.TEXTURE_2D, null); // Unbind the texture object
                }
                image.src = '../assets/sky.jpg';
                return texture
            }

            ///顶点数据
            const initArrayBufferForLaterUse = (gl, data, type, num) => {
                // Create a buffer object
                var buffer = gl.createBuffer();
                if (!buffer) {
                    console.log('Failed to create the buffer object');
                    return null;
                }
                // Write date into the buffer object
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

                // Store the necessary information to assign the object to the attribute variable later
                buffer.num = num;
                buffer.type = type;

                return buffer;
            }

            //索引数据
            const initElementArrayBufferForLaterUse = (gl, data, type) => {
                // Create a buffer object
                var buffer = gl.createBuffer();
                if (!buffer) {
                    console.log('Failed to create the buffer object');
                    return null;
                }
                // Write date into the buffer object
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);

                buffer.type = type;

                return buffer;
            }



            //内部方块的顶点数据数据  数据缓冲和纹理缓冲
            const initVertexBuffersForCube = () => {

                // Create a cube
                //    v6----- v5
                //   /|      /|
                //  v1------v0|
                //  | |     | |
                //  | |v7---|-|v4
                //  |/      |/
                //  v2------v3

                // Vertex coordinates
                var vertices = new Float32Array([
                    1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0,    // v0-v1-v2-v3 front
                    1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0,    // v0-v3-v4-v5 right
                    1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,    // v0-v5-v6-v1 up
                    -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0,    // v1-v6-v7-v2 left
                    -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,    // v7-v4-v3-v2 down
                    1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0     // v4-v7-v6-v5 back
                ]);

                // Texture coordinates
                var texCoords = new Float32Array([
                    1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,    // v0-v1-v2-v3 front
                    0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0,    // v0-v3-v4-v5 right
                    1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,    // v0-v5-v6-v1 up
                    1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,    // v1-v6-v7-v2 left
                    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,    // v7-v4-v3-v2 down
                    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0     // v4-v7-v6-v5 back
                ]);

                // Indices of the vertices
                var indices = new Uint8Array([
                    0, 1, 2, 0, 2, 3,    // front
                    4, 5, 6, 4, 6, 7,    // right
                    8, 9, 10, 8, 10, 11,    // up
                    12, 13, 14, 12, 14, 15,    // left
                    16, 17, 18, 16, 18, 19,    // down
                    20, 21, 22, 20, 22, 23     // back
                ])

                var o = new Object();  // Create the "Object" object to return multiple objects.

                // Write vertex information to buffer object
                o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, gl.FLOAT,3 );
                o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, gl.FLOAT,2 );
                o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE);
                if (!o.vertexBuffer || !o.texCoordBuffer || !o.indexBuffer) return null;

                o.numIndices = indices.length;

                // Unbind the buffer object
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                return o;
            }



            //外部四边形的顶点数据
            const initVertexBuffersForPlane = () => {
                // Create face
                //  v1------v0
                //  |        | 
                //  |        |
                //  |        |
                //  v2------v3

                // Vertex coordinates
                var vertices = new Float32Array([
                    1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0    // v0-v1-v2-v3
                ]);

                // Texture coordinates
                var texCoords = new Float32Array([1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0]);

                // Indices of the vertices
                var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);

                var o = new Object(); // Create the "Object" object to return multiple objects.

                // Write vertex information to buffer object
                o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, gl.FLOAT, 3);
                o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, gl.FLOAT, 2);
                o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_BYTE);
                if (!o.vertexBuffer || !o.texCoordBuffer || !o.indexBuffer) return null;
                o.numIndices = indices.length;

                // Unbind the buffer object
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                return o;
            }

            const initFramebufferObject = () => {
                let framebuffer, texture, depthBuffer;
                //1、 创建一个帧缓冲器区
                framebuffer = gl.createFramebuffer()

                // 2、创建纹理对象并设置其尺寸
                texture = gl.createTexture()
                gl.bindTexture(gl.TEXTURE_2D, texture)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, offsetScreen_Width, offsetScreent_hight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
                
                framebuffer.texture = texture // 建纹理对象存起来

                //3、  创建渲染缓冲区对象
                depthBuffer = gl.createRenderbuffer()
                //4 绑定渲染缓冲区对象并设置其尺寸
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer)
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, offsetScreen_Width, offsetScreent_hight)
                // 5 将帧缓冲区的颜色关联对象指定为一个纹理
                gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)
                //6 将帧缓冲区的深度关联对象指定为一个渲染缓冲区对象 也就是将渲染对象关联到帧缓冲区对象
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer)
                //7 检查帧缓冲区区对象是否被正确设置
                let isCheck = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
                if (isCheck !== gl.FRAMEBUFFER_COMPLETE) {
                    return null
                }
                //在帧缓存区对象渲染绘图
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                return framebuffer;

            }


            /**
             * 为为渲染对象设置纹理
            */
            function drawTexturedObject(o, texture) {
                initAttributeVariable(gl, a_Position, o.vertexBuffer);    // Vertex coordinates
                initAttributeVariable(gl, a_TextCoord, o.texCoordBuffer);  // Texture coordinates
                gl.activeTexture(gl.TEXTURE0);  ///这里激活纹理
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer);
                gl.drawElements(gl.TRIANGLES, o.numIndices, o.indexBuffer.type, 0);
            }

            // Assign the buffer objects and enable the assignment
            function initAttributeVariable(gl, a_attribute, buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(a_attribute, buffer.num, buffer.type, false, 0, 0);
                gl.enableVertexAttribArray(a_attribute);
            }

            //绘制帧缓冲区对象， 这里是一个方块
            const drawTexttureCube = (o, angle, texture, viewProjMatrix) => {
    
                modelMatrix.setRotate(20.0, 1.0, 0.0, 0.0);
                modelMatrix.rotate(angle, 0.0, 1.0, 0.0);
                mvpMatrix.set(viewProjMatrix);
                mvpMatrix.multiply(modelMatrix);
                gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix.elements);
                drawTexturedObject(o, texture);
            }

            //绘制真实物体，这里是一个矩形平面
            const drawTexturedPlane = (o, angle, texture, viewProjMatix) => {
                modelMatrix.setTranslate(0, 0, 1);
                modelMatrix.rotate(20.0, 1.0, 0.0, 0.0);
                modelMatrix.rotate(angle, 0.0, 1.0, 0.0);
                // Calculate the model view project matrix and pass it to u_MvpMatrix
                mvpMatrix.set(viewProjMatix);
                mvpMatrix.multiply(modelMatrix);
                gl.uniformMatrix4fv(u_mvpMatrix, false, mvpMatrix.elements);
                drawTexturedObject(o, texture);
            }

            //主绘制函数
            const draw = (canvas, flo, plane, cube, angle, texture, viewProjMatix, viewProjMatrixFBO) => {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo) //绑定帧缓冲区对象
                gl.viewport(0, 0, offsetScreen_Width, offsetScreent_hight) //开始在帧缓冲区对象里面绘制
                gl.clearColor(0.2, 0.2, 0.4, 1.0); // Set clear color (the color is slightly changed)
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);  // Clear FBO
                drawTexttureCube(cube, angle, texture, viewProjMatrixFBO)

                // drawTexturedPlane(cube,angle,texture,viewProjMatix)
                gl.bindFramebuffer(gl.FRAMEBUFFER, null)  //切换目标位颜色缓冲区
                gl.viewport(0, 0, canvas.width, canvas.height) //绘制真实的物体
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the color buffer
                //帧缓冲区获取保存的纹理对象当真实数据的纹理
                drawTexturedPlane(plane, angle, fbo.texture, viewProjMatix)
            }

            var ANGLE_STEP = 30;   // The increments of rotation angle (degrees)
            var last = Date.now(); // Last time that this function was called
            function animate(angle) {
                var now = Date.now();   // Calculate the elapsed time
                var elapsed = now - last;
                last = now;
                // Update the current rotation angle (adjusted by the elapsed time)
                var newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0;
                return newAngle % 360;
            }



            gl.enable(gl.DEPTH_TEST);   //  
            var viewProjMatrix = new Matrix4();   // Prepare view projection matrix for color buffer
            viewProjMatrix.setPerspective(30, canvasDom.width / canvasDom.height, 1.0, 100.0);
            viewProjMatrix.lookAt(0.0, 0.0, 7.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);


            var viewProjMatrixFBO = new Matrix4();   // Prepare view projection matrix for FBO
            viewProjMatrixFBO.setPerspective(30.0, offsetScreen_Width / offsetScreent_hight, 1.0, 100.0);
            viewProjMatrixFBO.lookAt(0.0, 2.0, 7.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

            var currentAngle = 0.0; // Current rotation angle (degrees)
            // Set the vertex information
            var cube = initVertexBuffersForCube();
            var plane = initVertexBuffersForPlane();
            const fbo = initFramebufferObject()
            const texture1 = inittextTure()
            const tick = () => {
                currentAngle = animate(currentAngle);  // Update current rotation angle
                draw(canvasDom, fbo, plane, cube, currentAngle, texture1, viewProjMatrix, viewProjMatrixFBO);
                requestAnimationFrame(tick, canvasDom);
            };
            tick();
        }

    </script>
</body>

</html>