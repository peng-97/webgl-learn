<!DOCTYPE html>

<head>

</head>

<body>
  <div style="font-size: 20px; text-align: center;">通过矩阵变形</div>
  <canvas id="canvasDom" width="400" height="400"></canvas>
  <script src="../lib/webgl-utils.js"></script>
  <script src="../lib/cuon-matrix.js"></script>  
  <!-- 矩阵变换库 -->
  <script src="../lib/webgl-debug.js"></script>
  <script src="../lib/cuon-utils.js"></script>
  <script>
    //定点着色器   说明了像素-定点的什么样的
    let vshader_source =
      'attribute vec4 a_Position;' +
      'uniform mat4 matrix;' +
      'void main(){' +
      'gl_Position =matrix*a_Position;' + //左乘一个矩阵
      'gl_PointSize=10.0;' +
      '}';
    //positong  表示是呢嘛位置
    //片元着色器   颜色是什么样
    let fshader_source =
      'precision mediump float;' +
      'uniform vec4 u_FragColor;' +
      'void main(){' +
      'gl_FragColor=vec4(1.0,0.0,0.0,1.0);' +
      '}';
    window.onload = function () {
      let canvasDom = document.getElementById("canvasDom");
      debugger
      let gl = getWebGLContext(canvasDom);//获得绘图上下文
      if (!gl) {
        console.log("不能使用webGl")
        return;
      }

      if (!initShaders(gl, vshader_source, fshader_source)) {
        console.log("不能初始化着色器");
        return;
      }
      let a_Position = gl.getAttribLocation(gl.program, 'a_Position') ///用变量 a_Positon 与顶点着色器  绑定
      let u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor') //绑定 片元着色器
      let u_Martix = gl.getUniformLocation(gl.program, 'matrix') //旋转参数
      console.log(u_Martix)

      if (!a_Position < 0) {
        console.log("没有能够获取着色器位置a_Positon")
        return;
      }
      // gl.vertexAttrib3f(a_Position,0.0,0.0,0.0) //给变量赋值  表是这是一个原点（xyzw)   webgl 原点在中间   向右向上为正   缺省第四个参数默认为1
      //vertexAttrib3f 赋值函数  js中的变量给glsl中的变量赋值
      //还有  1f 2f  4f  默认在原点
      // 矢量赋值
      // gl.vertexAttrib3fv(a_Position,new Float32Array([0.5,0,0.0]))// fv 表示可以接收一个数组

      // drawArrays   绘制函数
      // 第一个参数  mode   表示用于绘制什么类型 LINES TRIANGLES 
      //   第二个参数    表示用于  从哪个顶点开始绘制
      // 第三个参数   表示用于 绘制会用到多少顶点
      gl.clearColor(0.0, 1.0, 0.0, 1);//设置背景色
      gl.clear(gl.COLOR_BUFFER_BIT)
      const points = [0.0, 0.25, -0.25, -0.25, 0.25, -0.25];
      const angle = 90;//旋转角度

      const colors = []
      let canvasSize = { height: canvasDom.clientHeight, width: canvasDom.clientWidth }
      const matrix = [
        0.5, 0.0, 0.0, 0.0,
        0.0, 0.5, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      ] //矩阵是列主序列的
      //最好改成行主序列的
      /*
      转秩矩阵 需要改进
      */
      const getAMatrix = (martix, length) => {
        let x = length; //行数
        let y = martix.length / x;  //列数
        let t_martix = [];
        /**
         * 一维转为二维
         * */
        for (let i = 0; i < x; i++) {
          let x_martix = []
          for (let j = 0; j < y; j++) {
            x_martix.push(martix[j * y + i])
          }
          t_martix.push(x_martix)
        }
        console.log(t_martix)
        let result = []
        for (let i = 0; i < x; i++) {
          for (let j = 0; j < y; j++) {
            result.push(t_martix[i][j])
          }
        }
        return result
      }
      const nextMartix = getAMatrix(matrix, 4)
      console.log(nextMartix)
      const maxtixT=new Matrix4();
      const v_angle=90.0;
     maxtixT.translate(0.15,0,0)
      maxtixT.rotate(v_angle,0,0,1);
      gl.uniformMatrix4fv(u_Martix, false, maxtixT.elements) //false 是必须的
      const vertexBuffer = gl.createBuffer();//创建缓冲区对象
      if (!vertexBuffer) {
        console.log("无法创建buffer对象")
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) //缓冲区对象 绑定
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW)   //想缓冲区对象写数据 
      //gl.STATIC_DRAW  一次写入多次绘制  gl.STRREAM_DRAW   DYNAMIC_DRAW  多次写入多次绘制
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0)  //将缓冲区对象分配给变量 a_Position
      //方法说明  位置 、每个位置需要的顶点（1-4)(这是2 ，原本需要的 z,w,会默认补全) 、 数据类型格式（数据是什么类型）  相邻像个定点的字节数（默认是0） 、缓冲区对象中的偏移量（从那个位置开始用用顶点）
      gl.enableVertexAttribArray(a_Position) //开启变量分配
      // gl.disableVertexAttribArray(a_Position) //不安比变量分配
      gl.clearColor(0.0, 1.0, 0.0, 1);//设置背景色
      gl.clear(gl.COLOR_BUFFER_BIT)
      gl.drawArrays(gl.LINE_LOOP, 0, points.length / 2);   //  三角形   
      gl.deleteBuffer(vertexBuffer) //绘制完了删除缓冲区对象
    }
    // gl.drawArrays   就像一个绘制开关

  </script>
</body>

</html>